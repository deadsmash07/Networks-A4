Chat history
ChatGPT
ChatGPT
GPT
CS Tutor
GPT
Hot Mods
Paragraph Polishing Expert
GPT
Codeforces Coach
Today

    CSV File Analysis Request
    Reliable UDP File Transfer
    ccNUMA Overview and BenefChat history
ChatGPT
ChatGPT
GPT
CS Tutor
GPT
Hot Mods
Paragraph Polishing Expert
GPT
Codeforces Coach
Today

    CSV File Analysis Request
    Reliable UDP File Transfer
    ccNUMA Overview and Benefits

Yesterday

    UDP File Transfer Reliability
    UDP File Transfer Reliability
    Neural Network for Bird Classification
    Min Cut Computation Method
    Min-Cut Max-Flow Theorem
    Node Capacitated Maximum Flow

Previous 7 Days

    Floyd Warshall Applications
    Neural Network Parameters Overview
    Variational Inference Explained
    Industry Supply in Microeconomics
    Nobel Prize Economics 2024
    Logistic Regression vs SVM
    Logistic Regression and SVM Analysis
    Using TNER with IOB Data
    Transport Layer Overview
    TCP Connection Management Concepts
    UDP Reliability Mechanisms
    TCP over UDP Concepts
    Undirected to Directed Flow
    Count Paths in DAG
    Maximum Flow Iterations Example
    Pseudo Polynomial Algorithms Explained
    Delete Time Machine Snapshots
    Rational Capacities in Ford-Fulkerson
    OpenCL Presentation Summary

Add Team workspaceCollaborate on a Team plan
Temporary Chat
You said:
import socket
import time
import json
import argparse

"""
Modifications required: 
1. Add the option of sliding window. 
2. Lets follow the standard protocol that ACK_NUM is the Seq num of packet recieved by the client. Not the next! 
"""


MSS = 1400  # Maximum Segment Size
INITIAL_TIMEOUT = 1.0  # Initial timeout in seconds
DUP_ACK_THRESHOLD = 3

# RTT calculation parameters
ALPHA = 0.125
BETA = 0.25

class ReliableServer:
    def __init__(self, server_ip, server_port, enable_fast_recovery):
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.server_socket.bind((server_ip, server_port))
        self.enable_fast_recovery = enable_fast_recovery

        # RTT variables
        self.estimated_rtt = None
        self.dev_rtt = None
        self.timeout_interval = INITIAL_TIMEOUT
        self.last_ack = -1
        self.dup_ack_count = 0

        # Dictionary to store packet details: sent time, ack time, retransmission count, etc.
        self.packet_map = {}
        
        # File done 
        self.file_done = False
        
        
        # Sliding window
        self.window_size = 5
        self.window_base = 0
        
        
    #Correctly calculate the timeout interval
    def calculate_timeout(self, sample_rtt):
        if self.estimated_rtt is None:
            self.estimated_rtt = sample_rtt
            self.dev_rtt = sample_rtt / 2
        else:
            self.estimated_rtt = (1 - ALPHA) * self.estimated_rtt + ALPHA * sample_rtt
            self.dev_rtt = (1 - BETA) * self.dev_rtt + BETA * abs(sample_rtt - self.estimated_rtt)
        self.timeout_interval = max(1.0, self.estimated_rtt + 4 * self.dev_rtt)

    def send_packet(self, seq_num, data, client_address):
        
        """
            First create the json object encoded in utf-8 
            Then it sends the packet
            Then it Stores the packet info.
        """
        
        packet = json.dumps({
            "seq_num": seq_num,
            "data_len": len(data),
            "data": data.decode('latin1')
        }).encode('utf-8')
        self.server_socket.sendto(packet, client_address)
        self.packet_map[seq_num] = {
            "sent_time": time.time(),
            "ack_time": None,
            "retransmission_count": 0,
            "packet": packet
        }
        print(f"Sent packet with seq_num {seq_num}")

    def resend_packet(self, seq_num, client_address):
        """
        Resends the packet correctly and updates the retransmisson count. 
        """
        if seq_num not in self.packet_map:
            print(f"Packet with seq_num {seq_num} not found in packet_map. Cannot resend.")
            return
        
        packet_info = self.packet_map[seq_num]
        self.server_socket.sendto(packet_info["packet"], client_address)
        packet_info["sent_time"] = time.time()
        packet_info["retransmission_count"] += 1
        self.packet_map[seq_num] = packet_info
        print(f"Resent packet with seq_num {seq_num} (retransmission count: {packet_info['retransmission_count']})")
    # Receive the ack from the client
    def receive_ack(self):
        try:
            # This returns 1 packet at a time !! 
            ack_data, _ = self.server_socket.recvfrom(1024)
            ack_info = json.loads(ack_data.decode('utf-8'))
            return ack_info["ack_num"]
        except socket.timeout:
            return None

    # What about RTT update ? 
    def handle_ack(self, ack_num, client_address):
        if ack_num > self.last_ack:
            print(f"Received new ACK for seq_num {ack_num}")
            self.last_ack = ack_num
            self.dup_ack_count = 0
            self.window_base = ack_num + MSS # Move window base to the next packet

            # Update ACK time for each acknowledged packet in the map
            for seq in list(self.packet_map):
                if seq < ack_num:
                    self.packet_map[seq]["ack_time"] = time.time()
                    del self.packet_map[seq]  # Remove acknowledged packets

        else:
            # Increment duplicate ACK counter
            self.dup_ack_count += 1
            print(f"Received duplicate ACK for seq_num {ack_num}")
            if self.enable_fast_recovery and self.dup_ack_count >= DUP_ACK_THRESHOLD:
                print("Fast recovery triggered")
                # Packet to resend -> ack_num + MSS
                next_seq_num = ack_num + MSS
                self.resend_packet(next_seq_num, client_address)

    def run(self, file_path, client_address):
        
        # Inital code to set the correct window size. By getting an initial ack. 
        
        
        with open(file_path, 'rb') as file:
            # seq_num = 0
            while True:
                
                """
                if seq_num not in self.packet_map:
                    chunk = file.read(MSS)
                    if not chunk:
                        self.file_done = True
                    self.send_packet(seq_num, chunk, client_address)
                seq_num += MSS
                
                """
                seq_num = self.window_base
                while seq_num < self.window_base + self.window_size*MSS and not self.file_done:
                    if seq_num not in self.packet_map:
                        chunk = file.read(MSS)
                        if not chunk:
                            self.file_done = True
                        self.send_packet(seq_num, chunk, client_address)
                    seq_num += MSS
                
                

                # Check for ACKs
                self.server_